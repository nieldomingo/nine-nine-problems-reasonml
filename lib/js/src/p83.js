// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List                          = require("bs-platform/lib/js/list.js");
var $$Array                       = require("bs-platform/lib/js/array.js");
var Caml_obj                      = require("bs-platform/lib/js/caml_obj.js");
var Graph_term$NinetyNineProblems = require("./graph_term.js");

function s_tree(g) {
  var destination_node = function (nodes, new_edge) {
    var u = new_edge[0];
    var match = List.mem(u, nodes);
    if (match !== 0) {
      return new_edge[1];
    } else {
      return u;
    }
  };
  var neighbors = function (nodes, s) {
    return List.filter((function (edge) {
                    var v = edge[1];
                    var u = edge[0];
                    if (Caml_obj.caml_equal(u, s) || Caml_obj.caml_equal(v, s)) {
                      var match = Caml_obj.caml_equal(u, s);
                      var other = match !== 0 ? v : u;
                      return 1 - List.mem(other, nodes);
                    } else {
                      return /* false */0;
                    }
                  }))(g[/* edges */1]);
  };
  var recalc_candidate_edges = function (candidate_edges, nodes, new_edge) {
    var dest = destination_node(nodes, new_edge);
    return /* tuple */[
            /* :: */[
              dest,
              nodes
            ],
            List.rev_append(List.filter((function (edge) {
                          if (Caml_obj.caml_notequal(edge[0], dest)) {
                            return Caml_obj.caml_notequal(edge[1], dest);
                          } else {
                            return /* false */0;
                          }
                        }))(candidate_edges), neighbors(nodes, dest))
          ];
  };
  var traverse = function (candidate_edges, nodes, edges, trees) {
    if (candidate_edges) {
      return List.fold_left((function (trees, edge) {
                    var match = recalc_candidate_edges(candidate_edges, nodes, edge);
                    var new_edges = /* :: */[
                      edge,
                      edges
                    ];
                    return traverse(match[1], match[0], new_edges, trees);
                  }), trees, candidate_edges);
    } else {
      return /* :: */[
              /* record */[
                /* nodes */nodes,
                /* edges */edges
              ],
              trees
            ];
    }
  };
  var match = g[/* nodes */0];
  if (match) {
    var s = match[0];
    return traverse(neighbors(/* :: */[
                    s,
                    /* [] */0
                  ], s), /* :: */[
                s,
                /* [] */0
              ], /* [] */0, /* [] */0);
  } else {
    return /* [] */0;
  }
}

function is_tree(g) {
  return +(List.length(s_tree(g)) === 1);
}

function is_connected(g) {
  return List.exists((function (t) {
                return +(List.length(t[/* nodes */0]) === List.length(g[/* nodes */0]));
              }), s_tree(g));
}

console.log($$Array.of_list(List.map((function (tree) {
                return $$Array.of_list(tree[/* edges */1]);
              }), s_tree(Graph_term$NinetyNineProblems.another_example))));

console.log(is_tree(Graph_term$NinetyNineProblems.another_example));

console.log(is_connected(Graph_term$NinetyNineProblems.another_example));

var example_graph = Graph_term$NinetyNineProblems.example_graph;

var another_example = Graph_term$NinetyNineProblems.another_example;

exports.example_graph   = example_graph;
exports.another_example = another_example;
exports.s_tree          = s_tree;
exports.is_tree         = is_tree;
exports.is_connected    = is_connected;
/*  Not a pure module */
