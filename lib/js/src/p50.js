// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function push(heap, e) {
  return List.sort((function (a, b) {
                return a[0] - b[0] | 0;
              }), /* :: */[
              e,
              heap
            ]);
}

function pop(heap) {
  if (heap) {
    return /* tuple */[
            /* Some */[heap[0]],
            heap[1]
          ];
  } else {
    return /* tuple */[
            /* None */0,
            /* [] */0
          ];
  }
}

function form_tree(fs) {
  var heap = List.fold_left((function (heap, e) {
          return push(heap, /* tuple */[
                      e[1],
                      /* Node */[
                        e[0],
                        /* Empty */0,
                        /* Empty */0
                      ]
                    ]);
        }), /* [] */0, fs);
  var aux = function (_heap) {
    while(true) {
      var heap = _heap;
      var match = pop(heap);
      var match$1 = match[0];
      if (match$1) {
        var new_heap = match[1];
        var match$2 = match$1[0];
        if (new_heap) {
          var match$3 = pop(new_heap);
          var match$4 = match$3[0];
          if (match$4) {
            var match$5 = match$4[0];
            _heap = push(match$3[1], /* tuple */[
                  match$2[0] + match$5[0] | 0,
                  /* Node */[
                    "",
                    match$2[1],
                    match$5[1]
                  ]
                ]);
            continue ;
            
          } else {
            return Pervasives.failwith("Something went wrong.");
          }
        } else {
          return heap;
        }
      } else {
        return Pervasives.failwith("Something went wrong.");
      }
    };
  };
  var match = pop(aux(heap));
  var match$1 = match[0];
  if (match$1) {
    return match$1[0][1];
  } else {
    return Pervasives.failwith("Something went wrong.");
  }
}

function huffman(fs) {
  var traverse = function (_tree, _prefix, _accum) {
    while(true) {
      var accum = _accum;
      var prefix = _prefix;
      var tree = _tree;
      if (tree) {
        var c = tree[0];
        if (c === "") {
          _accum = traverse(tree[1], prefix + "0", accum);
          _prefix = prefix + "1";
          _tree = tree[2];
          continue ;
          
        } else {
          return /* :: */[
                  /* tuple */[
                    c,
                    prefix
                  ],
                  accum
                ];
        }
      } else {
        return Pervasives.failwith("Something went wrong.");
      }
    };
  };
  var tree = form_tree(fs);
  return traverse(tree, "", /* [] */0);
}

console.log(huffman(/* :: */[
          /* tuple */[
            "a",
            45
          ],
          /* :: */[
            /* tuple */[
              "b",
              13
            ],
            /* :: */[
              /* tuple */[
                "c",
                12
              ],
              /* :: */[
                /* tuple */[
                  "d",
                  16
                ],
                /* :: */[
                  /* tuple */[
                    "e",
                    9
                  ],
                  /* :: */[
                    /* tuple */[
                      "f",
                      5
                    ],
                    /* [] */0
                  ]
                ]
              ]
            ]
          ]
        ]));

console.log(huffman(/* :: */[
          /* tuple */[
            "a",
            10
          ],
          /* :: */[
            /* tuple */[
              "b",
              15
            ],
            /* :: */[
              /* tuple */[
                "c",
                30
              ],
              /* :: */[
                /* tuple */[
                  "d",
                  16
                ],
                /* :: */[
                  /* tuple */[
                    "e",
                    29
                  ],
                  /* [] */0
                ]
              ]
            ]
          ]
        ]));

exports.push      = push;
exports.pop       = pop;
exports.form_tree = form_tree;
exports.huffman   = huffman;
/*  Not a pure module */
