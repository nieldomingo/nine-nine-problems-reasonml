// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var Char                    = require("bs-platform/lib/js/char.js");
var List                    = require("bs-platform/lib/js/list.js");
var $$String                = require("bs-platform/lib/js/string.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_string             = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function string_of_tree(tree) {
  var aux = function (tree, accum) {
    var children = tree[1];
    var c = tree[0];
    if (children) {
      return List.fold_left((function (accum, child) {
                    return /* :: */[
                            /* "^" */94,
                            aux(child, accum)
                          ];
                  }), /* :: */[
                  c,
                  accum
                ], children);
    } else {
      return /* :: */[
              c,
              accum
            ];
    }
  };
  return $$String.concat("", List.map(Char.escaped, List.rev(aux(tree, /* [] */0)))) + "^";
}

function tree_of_string(encoded_tree) {
  var aux = function (_pos, _siblings) {
    while(true) {
      var siblings = _siblings;
      var pos = _pos;
      if (Caml_string.get(encoded_tree, pos) === /* "^" */94) {
        return /* tuple */[
                pos + 1 | 0,
                siblings
              ];
      } else {
        var match = aux(pos + 1 | 0, /* [] */0);
        var new_pos = match[0];
        var rev_children = List.rev(match[1]);
        if (new_pos < encoded_tree.length) {
          _siblings = /* :: */[
            /* T */[
              Caml_string.get(encoded_tree, pos),
              rev_children
            ],
            siblings
          ];
          _pos = new_pos;
          continue ;
          
        } else {
          return /* tuple */[
                  new_pos,
                  /* :: */[
                    /* T */[
                      Caml_string.get(encoded_tree, pos),
                      rev_children
                    ],
                    siblings
                  ]
                ];
        }
      }
    };
  };
  var match = aux(0, /* [] */0);
  var match$1 = match[1];
  if (match$1) {
    return match$1[0];
  } else {
    return Pervasives.failwith("invalid state");
  }
}

var t = /* T */[
  /* "a" */97,
  /* :: */[
    /* T */[
      /* "f" */102,
      /* :: */[
        /* T */[
          /* "g" */103,
          /* [] */0
        ],
        /* [] */0
      ]
    ],
    /* :: */[
      /* T */[
        /* "c" */99,
        /* [] */0
      ],
      /* :: */[
        /* T */[
          /* "b" */98,
          /* :: */[
            /* T */[
              /* "d" */100,
              /* [] */0
            ],
            /* :: */[
              /* T */[
                /* "e" */101,
                /* [] */0
              ],
              /* [] */0
            ]
          ]
        ],
        /* [] */0
      ]
    ]
  ]
];

var encoded_tree = string_of_tree(t);

console.log(encoded_tree);

var rec_t = tree_of_string(encoded_tree);

if (!Caml_obj.caml_equal(rec_t, t)) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        [
          "p70.re",
          52,
          2
        ]
      ];
}

console.log(string_of_tree(rec_t));

exports.string_of_tree = string_of_tree;
exports.tree_of_string = tree_of_string;
/* encoded_tree Not a pure module */
