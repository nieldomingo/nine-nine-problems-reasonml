// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var Char                    = require("bs-platform/lib/js/char.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_string             = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function string_of_tree(tree) {
  if (tree) {
    var left = tree[1];
    var v = tree[0];
    var exit = 0;
    if (left) {
      exit = 1;
    } else if (tree[2]) {
      exit = 1;
    } else {
      return v;
    }
    if (exit === 1) {
      return v + "(" + string_of_tree(left) + "," + string_of_tree(tree[2]) + ")";
    }
    
  } else {
    return "";
  }
}

function tree_of_string(encoded_tree) {
  var extract_children = function (pos) {
    if (pos === encoded_tree.length) {
      return /* tuple */[
              /* Empty */0,
              /* Empty */0,
              pos
            ];
    } else {
      var v = Caml_string.get(encoded_tree, pos);
      var exit = 0;
      var switcher = v - 40 | 0;
      if (switcher > 4 || switcher < 0) {
        exit = 1;
      } else {
        switch (switcher) {
          case 0 : 
              var match = extract_node(pos + 1 | 0);
              var new_pos = match[1];
              if (new_pos >= (encoded_tree.length - 1 | 0)) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "p67.re",
                        22,
                        10
                      ]
                    ];
              }
              if (Caml_string.get(encoded_tree, new_pos) !== /* "," */44) {
                throw [
                      Caml_builtin_exceptions.assert_failure,
                      [
                        "p67.re",
                        23,
                        10
                      ]
                    ];
              }
              var match$1 = extract_node(new_pos + 1 | 0);
              return /* tuple */[
                      match[0],
                      match$1[0],
                      match$1[1] + 1 | 0
                    ];
          case 2 : 
          case 3 : 
              exit = 1;
              break;
          case 1 : 
          case 4 : 
              return /* tuple */[
                      /* Empty */0,
                      /* Empty */0,
                      pos
                    ];
          
        }
      }
      if (exit === 1) {
        return Pervasives.failwith("expected '(', ',', ')', got " + Char.escaped(v));
      }
      
    }
  };
  var extract_node = function (pos) {
    if (pos === encoded_tree.length) {
      return /* tuple */[
              /* Empty */0,
              pos
            ];
    } else {
      var v = Caml_string.get(encoded_tree, pos);
      if (v !== 41) {
        if (v !== 44) {
          var match = extract_children(pos + 1 | 0);
          return /* tuple */[
                  /* Node */[
                    Char.escaped(v),
                    match[0],
                    match[1]
                  ],
                  match[2]
                ];
        } else {
          return /* tuple */[
                  /* Empty */0,
                  pos
                ];
        }
      } else {
        return /* tuple */[
                /* Empty */0,
                pos
              ];
      }
    }
  };
  return extract_node(0)[0];
}

var example_layout_tree_001 = /* Node */[
  "b",
  /* Node */[
    "d",
    /* Empty */0,
    /* Empty */0
  ],
  /* Node */[
    "e",
    /* Empty */0,
    /* Empty */0
  ]
];

var example_layout_tree_002 = /* Node */[
  "c",
  /* Empty */0,
  /* Node */[
    "f",
    /* Node */[
      "g",
      /* Empty */0,
      /* Empty */0
    ],
    /* Empty */0
  ]
];

var example_layout_tree = /* Node */[
  "a",
  example_layout_tree_001,
  example_layout_tree_002
];

console.log(string_of_tree(example_layout_tree));

console.log(tree_of_string(string_of_tree(example_layout_tree)));

exports.string_of_tree = string_of_tree;
exports.tree_of_string = tree_of_string;
/*  Not a pure module */
